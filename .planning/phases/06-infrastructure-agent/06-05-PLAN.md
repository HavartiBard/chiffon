# Phase 6 Plan 05: Template Generation

---
phase: 06-infrastructure-agent
plan: 05
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/agents/infra_agent/template_generator.py
  - src/agents/infra_agent/templates/
  - src/agents/infra_agent/agent.py
  - tests/test_template_generator.py
autonomous: true
must_haves:
  truths:
    - "TemplateGenerator creates Ansible playbook scaffolds from service name"
    - "Generated templates follow Ansible Galaxy best practices"
    - "Templates include roles structure, handlers, variables, and documentation"
    - "Templates conform to homelab conventions from existing playbooks"
    - "Generation available via work_type='generate_template'"
  artifacts:
    - path: "src/agents/infra_agent/template_generator.py"
      provides: "TemplateGenerator using Jinja2"
      exports: ["TemplateGenerator", "GeneratedTemplate"]
    - path: "src/agents/infra_agent/templates/"
      provides: "Jinja2 template files for playbook generation"
  key_links:
    - from: "src/agents/infra_agent/template_generator.py"
      to: "Jinja2"
      via: "template rendering"
      pattern: "Environment.*render"
    - from: "src/agents/infra_agent/agent.py"
      to: "src/agents/infra_agent/template_generator.py"
      via: "work_type dispatch"
      pattern: "template_generator\\.generate"
---

<objective>
Create the TemplateGenerator service that generates Ansible playbook scaffolds following Galaxy best practices and homelab conventions.

Purpose: This implements INFRA-04 - the agent must generate new playbook templates for common tasks. When no matching playbook exists for a service, the agent can scaffold a starting point.

Output: TemplateGenerator that creates complete playbook scaffolds with roles, handlers, variables, and documentation following Ansible Galaxy patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-agent/06-CONTEXT.md
@.planning/phases/06-infrastructure-agent/06-RESEARCH.md
@src/agents/infra_agent/agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jinja2 template files</name>
  <files>
    src/agents/infra_agent/templates/playbook.yml.j2
    src/agents/infra_agent/templates/role_tasks_main.yml.j2
    src/agents/infra_agent/templates/role_handlers_main.yml.j2
    src/agents/infra_agent/templates/role_defaults_main.yml.j2
    src/agents/infra_agent/templates/role_meta_main.yml.j2
    src/agents/infra_agent/templates/README.md.j2
  </files>
  <action>
Create Jinja2 template files for Galaxy-compliant playbook generation:

1. Create src/agents/infra_agent/templates/ directory

2. Create playbook.yml.j2 (main playbook template):
```jinja2
---
# chiffon:service={{ service_name }}
# chiffon:description={{ description }}
# Generated by Chiffon Infrastructure Agent
# Template version: 1.0

- name: Deploy {{ service_name | title }}
  hosts: {{ hosts | default('all') }}
  become: {{ become | default('yes') }}
  vars:
    service_name: "{{ service_name }}"
    service_port: {{ service_port | default(8080) }}
    service_user: "{{ service_user | default(service_name) }}"
    service_group: "{{ service_group | default(service_name) }}"
    config_dir: "/etc/{{ service_name }}"
    data_dir: "/var/lib/{{ service_name }}"
    log_dir: "/var/log/{{ service_name }}"

  pre_tasks:
    - name: Verify target connectivity
      ansible.builtin.ping:
      tags:
        - always

  roles:
    - role: {{ service_name }}
      tags:
        - {{ service_name }}
        - deploy

  post_tasks:
    - name: Verify {{ service_name }} is running
      ansible.builtin.service:
        name: "{{ service_name }}"
        state: started
      register: service_status
      ignore_errors: yes
      tags:
        - verify
```

3. Create role_tasks_main.yml.j2 (role tasks):
```jinja2
---
# Tasks for {{ service_name }} role

- name: Install {{ service_name }} dependencies
  ansible.builtin.apt:
    name: "{{ '{{' }} item {{ '}}' }}"
    state: present
    update_cache: yes
  loop:
    - curl
    - ca-certificates
  tags:
    - install
    - dependencies

- name: Create {{ service_name }} user
  ansible.builtin.user:
    name: "{{ '{{' }} service_user {{ '}}' }}"
    group: "{{ '{{' }} service_group {{ '}}' }}"
    system: yes
    create_home: no
    shell: /usr/sbin/nologin
  tags:
    - install

- name: Create {{ service_name }} directories
  ansible.builtin.file:
    path: "{{ '{{' }} item {{ '}}' }}"
    state: directory
    owner: "{{ '{{' }} service_user {{ '}}' }}"
    group: "{{ '{{' }} service_group {{ '}}' }}"
    mode: '0755'
  loop:
    - "{{ '{{' }} config_dir {{ '}}' }}"
    - "{{ '{{' }} data_dir {{ '}}' }}"
    - "{{ '{{' }} log_dir {{ '}}' }}"
  tags:
    - install

- name: Deploy {{ service_name }} configuration
  ansible.builtin.template:
    src: "{{ service_name }}.conf.j2"
    dest: "{{ '{{' }} config_dir {{ '}}' }}/{{ service_name }}.conf"
    owner: "{{ '{{' }} service_user {{ '}}' }}"
    group: "{{ '{{' }} service_group {{ '}}' }}"
    mode: '0640'
  notify: Restart {{ service_name }}
  tags:
    - config

- name: Deploy {{ service_name }} systemd unit
  ansible.builtin.template:
    src: "{{ service_name }}.service.j2"
    dest: "/etc/systemd/system/{{ service_name }}.service"
    owner: root
    group: root
    mode: '0644'
  notify:
    - Reload systemd
    - Restart {{ service_name }}
  tags:
    - install
    - systemd

- name: Enable and start {{ service_name }}
  ansible.builtin.systemd:
    name: "{{ service_name }}"
    enabled: yes
    state: started
    daemon_reload: yes
  tags:
    - service
```

4. Create role_handlers_main.yml.j2:
```jinja2
---
# Handlers for {{ service_name }} role

- name: Reload systemd
  ansible.builtin.systemd:
    daemon_reload: yes

- name: Restart {{ service_name }}
  ansible.builtin.systemd:
    name: "{{ service_name }}"
    state: restarted
  when: ansible_service_mgr == "systemd"

- name: Reload {{ service_name }}
  ansible.builtin.systemd:
    name: "{{ service_name }}"
    state: reloaded
  when: ansible_service_mgr == "systemd"
```

5. Create role_defaults_main.yml.j2:
```jinja2
---
# Default variables for {{ service_name }} role

# Service configuration
{{ service_name }}_version: "latest"
{{ service_name }}_port: {{ service_port | default(8080) }}
{{ service_name }}_bind_address: "0.0.0.0"

# User and permissions
service_user: "{{ service_name }}"
service_group: "{{ service_name }}"

# Paths
config_dir: "/etc/{{ service_name }}"
data_dir: "/var/lib/{{ service_name }}"
log_dir: "/var/log/{{ service_name }}"

# Logging
{{ service_name }}_log_level: "info"

# Resource limits
{{ service_name }}_memory_limit: "512M"
{{ service_name }}_cpu_quota: "100%"
```

6. Create role_meta_main.yml.j2:
```jinja2
---
# Meta information for {{ service_name }} role

galaxy_info:
  role_name: {{ service_name }}
  author: Chiffon Infrastructure Agent
  description: Deploy and configure {{ service_name }} service
  company: Homelab
  license: MIT
  min_ansible_version: "2.10"

  platforms:
    - name: Debian
      versions:
        - bullseye
        - bookworm
    - name: Ubuntu
      versions:
        - focal
        - jammy

  galaxy_tags:
    - {{ service_name }}
    - deployment
    - homelab

dependencies: []
```

7. Create README.md.j2:
```jinja2
# {{ service_name | title }} Ansible Role

Deploys and configures {{ service_name }} service.

## Requirements

- Ansible 2.10+
- Target: Debian/Ubuntu

## Role Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `{{ service_name }}_version` | `latest` | Version to install |
| `{{ service_name }}_port` | `{{ service_port | default(8080) }}` | Service port |
| `service_user` | `{{ service_name }}` | Service user |

## Dependencies

None.

## Example Playbook

```yaml
- hosts: servers
  roles:
    - role: {{ service_name }}
      {{ service_name }}_port: 9090
```

## License

MIT

## Author

Generated by Chiffon Infrastructure Agent
```
  </action>
  <verify>
    - [ ] All template files created in src/agents/infra_agent/templates/
    - [ ] Templates use valid Jinja2 syntax
    - [ ] Playbook template includes chiffon metadata comments
    - [ ] Role templates follow Galaxy structure
  </verify>
  <done>Jinja2 template files created for Galaxy-compliant playbook generation</done>
</task>

<task type="auto">
  <name>Task 2: Create TemplateGenerator service</name>
  <files>
    src/agents/infra_agent/template_generator.py
  </files>
  <action>
Create the TemplateGenerator service using Jinja2:

1. Create src/agents/infra_agent/template_generator.py

2. GeneratedTemplate Pydantic model:
   - service_name: str
   - playbook_content: str (rendered playbook YAML)
   - role_structure: dict[str, str] (path -> content mapping for role files)
   - readme_content: str
   - generated_at: datetime
   - output_paths: list[str] (suggested file paths for writing)

3. TemplateGenerator class:
   - __init__(templates_dir: Optional[Path] = None):
     - self.templates_dir = templates_dir or Path(__file__).parent / "templates"
     - self.env = Environment(
         loader=FileSystemLoader(self.templates_dir),
         trim_blocks=True,
         lstrip_blocks=True,
         keep_trailing_newline=True,
       )

   - async generate_template(
       service_name: str,
       description: Optional[str] = None,
       service_port: int = 8080,
       hosts: str = "all",
       become: bool = True,
       extra_vars: Optional[dict] = None
     ) -> GeneratedTemplate:
     - Normalize service_name (lowercase, replace spaces with dashes)
     - Build context dict with all parameters
     - Render each template file
     - Build role structure dict
     - Return GeneratedTemplate

   - def _render_template(template_name: str, context: dict) -> str:
     - Load template from env
     - Render with context
     - Return rendered string

   - def _build_role_structure(service_name: str, context: dict) -> dict[str, str]:
     - Create Galaxy-compliant role directory structure:
       - roles/{service_name}/tasks/main.yml
       - roles/{service_name}/handlers/main.yml
       - roles/{service_name}/defaults/main.yml
       - roles/{service_name}/meta/main.yml
       - roles/{service_name}/templates/ (empty placeholder)
       - roles/{service_name}/files/ (empty placeholder)
     - Render each role file from template
     - Return dict mapping path to content

   - def _generate_output_paths(service_name: str) -> list[str]:
     - Return suggested paths for writing:
       - {service_name}-deploy.yml (main playbook)
       - roles/{service_name}/tasks/main.yml
       - roles/{service_name}/handlers/main.yml
       - roles/{service_name}/defaults/main.yml
       - roles/{service_name}/meta/main.yml
       - README-{service_name}.md

   - async write_template_to_disk(
       template: GeneratedTemplate,
       output_dir: Path,
       overwrite: bool = False
     ) -> list[Path]:
     - Create output_dir if not exists
     - Write playbook file
     - Create role directory structure
     - Write each role file
     - Write README
     - If overwrite=False, skip existing files (log warning)
     - Return list of written paths

4. Service name normalization:
   - Lowercase
   - Replace spaces and underscores with dashes
   - Remove special characters
   - Validate: must be 1-50 chars, alphanumeric + dashes only

5. Template rendering context:
   ```python
   context = {
       "service_name": service_name,
       "description": description or f"Deploy {service_name} service",
       "service_port": service_port,
       "hosts": hosts,
       "become": "yes" if become else "no",
       "service_user": service_name,
       "service_group": service_name,
       **(extra_vars or {}),
   }
   ```

6. Error handling:
   - InvalidServiceNameError: If service_name fails validation
   - TemplateRenderError: If Jinja2 rendering fails
   - FileExistsError: If file exists and overwrite=False
  </action>
  <verify>
    - [ ] TemplateGenerator initializes with templates directory
    - [ ] generate_template returns GeneratedTemplate with all fields
    - [ ] Service name normalization works correctly
    - [ ] Role structure follows Galaxy layout
    - [ ] write_template_to_disk creates files correctly
  </verify>
  <done>TemplateGenerator service created with Jinja2 rendering and Galaxy-compliant output</done>
</task>

<task type="auto">
  <name>Task 3: Integrate into InfraAgent and create tests</name>
  <files>
    src/agents/infra_agent/agent.py
    tests/test_template_generator.py
  </files>
  <action>
Update InfraAgent to support template generation and create comprehensive tests:

1. Update src/agents/infra_agent/agent.py:

   a. Add imports:
      - from .template_generator import TemplateGenerator, GeneratedTemplate

   b. Update __init__:
      - Initialize self.template_generator = TemplateGenerator()

   c. Update execute_work to handle work_type == "generate_template":
      - Get service_name from parameters["service_name"]
      - Get optional parameters: description, service_port, hosts, become, extra_vars
      - Call template_generator.generate_template(...)
      - Optionally write to disk if parameters.get("write_to_disk", False)
      - Return WorkResult with:
        - output: JSON with playbook_content, role_structure keys, output_paths
        - status: "completed"

   d. Update execute_work for no-match case in "deploy_service":
      - If task_mapper returns no match:
        - Include template generation option in suggestion:
        - "No matching playbook found. Use work_type='generate_template' with service_name='[extracted]' to create a scaffold."

2. Create tests/test_template_generator.py:

   TestGeneratedTemplate:
   - test_valid_template: All fields present
   - test_role_structure_has_required_paths: Galaxy paths included
   - test_output_paths_generated: Suggested paths populated

   TestServiceNameValidation:
   - test_valid_service_name: Alphanumeric with dashes
   - test_normalize_spaces: "My Service" -> "my-service"
   - test_normalize_underscores: "my_service" -> "my-service"
   - test_invalid_empty: Raises InvalidServiceNameError
   - test_invalid_special_chars: Raises InvalidServiceNameError

   TestTemplateRendering:
   - test_playbook_has_service_name: Variable substituted
   - test_playbook_has_metadata_comments: chiffon:service present
   - test_role_tasks_valid_yaml: Parses as YAML
   - test_role_handlers_valid_yaml: Parses as YAML
   - test_role_defaults_valid_yaml: Parses as YAML
   - test_readme_has_service_name: Service name in title

   TestTemplateGeneration:
   - test_generate_with_defaults: Default port 8080, hosts "all"
   - test_generate_with_custom_port: Custom port reflected
   - test_generate_with_description: Description in playbook
   - test_generate_with_extra_vars: Extra vars in context

   TestWriteToDisk:
   - test_creates_playbook_file: Playbook written
   - test_creates_role_directories: Role structure created
   - test_skip_existing_no_overwrite: Existing files not overwritten
   - test_overwrite_existing: With overwrite=True, files replaced

   TestInfraAgentTemplateGeneration:
   - test_generate_template_work_type: work_type dispatches correctly
   - test_template_in_output: WorkResult contains template content
   - test_write_to_disk_parameter: Files written when requested

3. Use pytest fixtures:
   - temp_templates_dir: Copy of real templates for testing
   - temp_output_dir: Temporary directory for write tests
   - sample_context: Standard context for rendering tests

4. Verify rendered YAML is valid using PyYAML:
   ```python
   import yaml
   yaml.safe_load(rendered_content)  # Should not raise
   ```
  </action>
  <verify>
    - [ ] All tests pass: `pytest tests/test_template_generator.py -v`
    - [ ] Test coverage > 90% for template_generator.py
    - [ ] Rendered templates are valid YAML
    - [ ] InfraAgent handles generate_template work_type
  </verify>
  <done>TemplateGenerator integrated into InfraAgent; comprehensive test suite created with 25+ tests</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run tests: `pytest tests/test_template_generator.py -v`
2. Verify imports: `python -c "from src.agents.infra_agent.template_generator import TemplateGenerator; print('Import OK')"`
3. Generate sample template: `python -c "from src.agents.infra_agent.template_generator import TemplateGenerator; t = TemplateGenerator(); import asyncio; r = asyncio.run(t.generate_template('myapp')); print(r.playbook_content[:200])"`
</verification>

<success_criteria>
- TemplateGenerator creates complete playbook scaffolds
- Generated templates follow Ansible Galaxy best practices (roles structure)
- Templates include metadata comments (chiffon:service, chiffon:description)
- Templates include roles, handlers, defaults, meta, README
- Service name validation and normalization works
- InfraAgent supports work_type="generate_template"
- Generated YAML is syntactically valid
- All tests pass (target: 25+ test cases)
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-agent/06-05-SUMMARY.md`
</output>
