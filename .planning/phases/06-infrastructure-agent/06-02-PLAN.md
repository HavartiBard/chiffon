# Phase 6 Plan 02: Task-to-Playbook Mapping

---
phase: 06-infrastructure-agent
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/infra_agent/task_mapper.py
  - src/agents/infra_agent/cache_manager.py
  - alembic/versions/006_playbook_mappings.py
  - src/common/models.py
  - tests/test_task_mapper.py
autonomous: true
must_haves:
  truths:
    - "TaskMapper maps service-level intents to playbook paths"
    - "Hybrid matching: exact -> cached -> semantic (FAISS) with threshold >= 0.85"
    - "Semantic mappings cached in PostgreSQL for cost efficiency"
    - "Multiple matches returned with confidence scores"
    - "No-match case returns suggestions or template generation option"
  artifacts:
    - path: "src/agents/infra_agent/task_mapper.py"
      provides: "TaskMapper service with hybrid matching"
      exports: ["TaskMapper", "MappingResult"]
    - path: "src/agents/infra_agent/cache_manager.py"
      provides: "Cache manager for semantic mappings"
      exports: ["CacheManager"]
    - path: "alembic/versions/006_playbook_mappings.py"
      provides: "Database migration for semantic mapping cache"
  key_links:
    - from: "src/agents/infra_agent/task_mapper.py"
      to: "FAISS index"
      via: "faiss.IndexFlatIP"
      pattern: "index\\.search"
    - from: "src/agents/infra_agent/task_mapper.py"
      to: "sentence_transformers"
      via: "embedding generation"
      pattern: "SentenceTransformer"
---

<objective>
Create the TaskMapper service that maps service-level intents (e.g., "Deploy Kuma") to Ansible playbook paths using a hybrid matching strategy: exact match -> cached previous mapping -> FAISS semantic search.

Purpose: This is the core of INFRA-01 - the agent must accept deployment tasks and map them to existing playbooks. The orchestrator sends service-level intents, not playbook-specific commands.

Output: TaskMapper service that resolves task intents to playbooks with confidence scores, supporting multi-match scenarios and caching learned mappings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-agent/06-CONTEXT.md
@.planning/phases/06-infrastructure-agent/06-RESEARCH.md
@src/common/models.py
@src/common/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration and cache manager</name>
  <files>
    alembic/versions/006_playbook_mappings.py
    src/common/models.py
    src/agents/infra_agent/cache_manager.py
  </files>
  <action>
Create database schema and cache manager for semantic mapping persistence:

1. Create alembic/versions/006_playbook_mappings.py:
   - Table: playbook_mappings
   - Columns:
     - id: Integer, primary key, autoincrement
     - intent: String(500), not null (the task intent text)
     - intent_hash: String(64), unique, not null (SHA256 of normalized intent)
     - playbook_path: String(500), not null
     - confidence: Float, not null (0.0-1.0)
     - match_method: String(50), not null ('exact', 'cached', 'semantic')
     - embedding_vector: JSONB, nullable (stored as list for portability)
     - created_at: DateTime, not null
     - last_used_at: DateTime, not null
     - use_count: Integer, not null, default=1
   - Indexes:
     - idx_playbook_mappings_intent_hash on intent_hash (unique)
     - idx_playbook_mappings_confidence on confidence (for threshold queries)

2. Add PlaybookMapping ORM model to src/common/models.py:
   - Match migration columns
   - Add __repr__ method
   - Add class method normalize_intent(intent: str) -> str that lowercases and strips whitespace

3. Create src/agents/infra_agent/cache_manager.py:
   - CacheManager class:
     - __init__(db_session: AsyncSession):
       - self.db = db_session

     - async lookup_cached_mapping(intent: str) -> Optional[PlaybookMapping]:
       - Normalize intent using PlaybookMapping.normalize_intent()
       - Hash with SHA256
       - Query playbook_mappings where intent_hash matches and confidence >= 0.85
       - If found, update last_used_at and use_count
       - Return PlaybookMapping or None

     - async cache_mapping(intent: str, playbook_path: str, confidence: float, method: str, embedding: Optional[list[float]] = None):
       - Normalize and hash intent
       - Upsert into playbook_mappings (ON CONFLICT UPDATE)
       - Store embedding_vector if provided

     - async get_all_cached_embeddings() -> list[tuple[str, list[float]]]:
       - Return list of (playbook_path, embedding_vector) for all cached entries with embeddings
       - Used to warm FAISS index on startup
  </action>
  <verify>
    - [ ] Migration 006 runs: `alembic upgrade head`
    - [ ] PlaybookMapping model validates correctly
    - [ ] CacheManager can store and retrieve mappings
    - [ ] Intent normalization and hashing works consistently
  </verify>
  <done>Database migration for playbook_mappings created, CacheManager for semantic cache operations implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create TaskMapper with hybrid matching</name>
  <files>
    src/agents/infra_agent/task_mapper.py
  </files>
  <action>
Create the TaskMapper service with three-tier hybrid matching:

1. Create src/agents/infra_agent/task_mapper.py

2. MappingResult Pydantic model:
   - playbook_path: Optional[str] (None if no match)
   - confidence: float (0.0-1.0)
   - method: str ('exact', 'cached', 'semantic', 'none')
   - alternatives: list[dict] (other matches with scores, max 3)
   - suggestion: Optional[str] (suggestion if no match, e.g., "Generate template for X")

3. TaskMapper class:
   - __init__(cache_manager: CacheManager, playbook_catalog: list[PlaybookMetadata]):
     - self.cache_manager = cache_manager
     - self.playbook_catalog = playbook_catalog
     - self.embedder: Optional[SentenceTransformer] = None (lazy load)
     - self.index: Optional[faiss.IndexFlatIP] = None (lazy build)
     - self._catalog_embeddings: Optional[np.ndarray] = None

   - async map_task_to_playbook(task_intent: str, top_k: int = 3) -> MappingResult:
     - Step 1: Try exact match (service name in intent)
     - Step 2: Try cached mapping lookup
     - Step 3: Try semantic search with FAISS
     - Return MappingResult with best match and alternatives

   - def _exact_match(task_intent: str) -> Optional[str]:
     - Normalize intent to lowercase
     - For each playbook in catalog:
       - If playbook.service and playbook.service.lower() in task_intent.lower():
         - Return playbook.path
     - Return None

   - async _cached_match(task_intent: str) -> Optional[MappingResult]:
     - Call cache_manager.lookup_cached_mapping(task_intent)
     - If found with confidence >= 0.85, return MappingResult with method='cached'
     - Return None

   - async _semantic_match(task_intent: str, top_k: int) -> MappingResult:
     - Lazy-load embedder: SentenceTransformer('all-MiniLM-L6-v2')
     - Lazy-build FAISS index if not exists
     - Embed task_intent
     - Normalize embedding (L2 norm) for cosine similarity via inner product
     - Search index for top_k matches
     - If best match score >= 0.85:
       - Cache the mapping via cache_manager
       - Return MappingResult with method='semantic'
     - Else:
       - Return MappingResult with method='none', suggestion="No matching playbook found. Consider: Generate template for [service]"

   - async _build_faiss_index():
     - Generate descriptions: "{service} {description}" for each playbook
     - Embed all descriptions
     - Normalize embeddings
     - Create faiss.IndexFlatIP(dimension)
     - Add embeddings to index
     - Store mapping of index position -> playbook

   - def _generate_no_match_suggestion(task_intent: str) -> str:
     - Extract likely service name from intent (first noun after "deploy", "install", "setup")
     - Return suggestion like "No matching playbook. Options: 1) Generate template for '[service]', 2) Search homelab-infra manually, 3) Create custom playbook"

4. Use sentence-transformers 'all-MiniLM-L6-v2' model (384 dimensions, fast, good for semantic similarity)

5. Confidence threshold: 0.85 for accepting semantic matches (from RESEARCH.md)

6. Handle edge cases:
   - Empty catalog -> return MappingResult with method='none'
   - FAISS import error -> graceful fallback to exact + cached only
   - Embedding model load failure -> log error, return exact match result only
  </action>
  <verify>
    - [ ] TaskMapper initializes with catalog
    - [ ] Exact match works: "Deploy Kuma" matches playbook with service="kuma"
    - [ ] Cached match returns previously stored mapping
    - [ ] Semantic match uses FAISS with cosine similarity
    - [ ] Confidence threshold 0.85 enforced
    - [ ] No-match returns suggestions
  </verify>
  <done>TaskMapper service created with hybrid matching (exact -> cached -> semantic) and FAISS integration</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive tests</name>
  <files>
    tests/test_task_mapper.py
  </files>
  <action>
Create comprehensive test suite for TaskMapper and CacheManager:

1. Create tests/test_task_mapper.py

2. TestMappingResult:
   - test_valid_mapping_result: All fields validate
   - test_alternatives_max_three: Alternatives list capped at 3
   - test_no_match_has_suggestion: method='none' requires suggestion

3. TestCacheManager (use pytest-asyncio):
   - test_lookup_nonexistent_returns_none
   - test_cache_and_lookup: Store mapping, retrieve it
   - test_intent_normalization: "Deploy KUMA" and "deploy kuma" hash same
   - test_use_count_incremented: Lookup increments use_count
   - test_confidence_threshold: Only return if confidence >= 0.85

4. TestTaskMapperExactMatch:
   - test_exact_match_service_in_intent: "Deploy Kuma" -> kuma-deploy.yml
   - test_exact_match_case_insensitive: "deploy KUMA" works
   - test_exact_match_no_service: Playbook without service field skipped
   - test_exact_match_multiple_services: Returns first match

5. TestTaskMapperCachedMatch:
   - test_cached_match_returns_stored: Previously cached intent returns same playbook
   - test_cached_match_updates_last_used: Timestamp updated on hit
   - test_cached_match_low_confidence_skipped: confidence < 0.85 not returned

6. TestTaskMapperSemanticMatch:
   - test_semantic_match_similar_intent: "Install Kuma service" matches "kuma-deploy.yml"
   - test_semantic_match_threshold_enforced: Score < 0.85 returns no match
   - test_semantic_match_caches_result: New semantic match stored in cache
   - test_semantic_match_returns_alternatives: top_k=3 returns 3 alternatives

7. TestTaskMapperNoMatch:
   - test_no_match_returns_suggestion: Empty catalog returns helpful suggestion
   - test_no_match_extracts_service_name: Suggestion includes likely service

8. TestTaskMapperIntegration:
   - test_hybrid_priority: exact > cached > semantic
   - test_full_workflow: New intent -> semantic match -> cache -> second call uses cache

9. Use pytest fixtures:
   - sample_playbook_catalog: List of PlaybookMetadata with varied services
   - mock_cache_manager: Mocked CacheManager for unit tests
   - in_memory_db: SQLite in-memory for integration tests

10. Mock sentence-transformers for unit tests (avoid model download in CI):
    - Use unittest.mock to mock SentenceTransformer.encode()
    - Return fixed embeddings for deterministic tests
  </action>
  <verify>
    - [ ] All tests pass: `pytest tests/test_task_mapper.py -v`
    - [ ] Test coverage > 90% for task_mapper.py
    - [ ] Semantic tests use mocked embeddings (no model download in CI)
    - [ ] Integration tests verify full workflow
  </verify>
  <done>Comprehensive test suite for TaskMapper with 30+ test cases covering all matching strategies</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run migration: `alembic upgrade head`
2. Run tests: `pytest tests/test_task_mapper.py -v`
3. Verify imports: `python -c "from src.agents.infra_agent.task_mapper import TaskMapper, MappingResult; print('Import OK')"`
4. Verify cache manager: `python -c "from src.agents.infra_agent.cache_manager import CacheManager; print('Cache OK')"`
</verification>

<success_criteria>
- TaskMapper maps service-level intents to playbook paths
- Three-tier matching: exact (fast) -> cached (fast) -> semantic (FAISS)
- Semantic similarity threshold >= 0.85 enforced
- Learned mappings cached in PostgreSQL for future use
- Multiple matches returned with confidence scores (alternatives list)
- No-match case provides actionable suggestions
- All tests pass (target: 30+ test cases)
- CI-friendly: semantic tests use mocked embeddings
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-agent/06-02-SUMMARY.md`
</output>
