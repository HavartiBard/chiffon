---
phase: 05-state-and-audit
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/orchestrator/audit.py
  - src/orchestrator/api.py
  - tests/test_audit_service.py
autonomous: true

must_haves:
  truths:
    - "Query 'all failures in last week' returns failed tasks within time range"
    - "Query 'all changes to service X' returns tasks with service in services_touched"
    - "Combined filtering (status + time + service) works correctly"
    - "REST endpoints return paginated results with proper JSON format"
  artifacts:
    - path: "src/orchestrator/audit.py"
      provides: "AuditService with query methods"
      exports: ["AuditService", "get_failures", "get_by_service", "audit_query"]
    - path: "src/orchestrator/api.py"
      provides: "Extended REST API with /audit/* endpoints"
      contains: "/api/v1/audit"
    - path: "tests/test_audit_service.py"
      provides: "Test suite for audit queries"
      min_lines: 200
  key_links:
    - from: "src/orchestrator/audit.py"
      to: "src/common/models.py"
      via: "Task ORM model queries"
      pattern: "Task\\.services_touched\\.contains"
    - from: "src/orchestrator/api.py"
      to: "src/orchestrator/audit.py"
      via: "AuditService dependency injection"
      pattern: "AuditService"
---

<objective>
Create AuditService for execution history queries and REST endpoints for audit access.

Purpose: Enables STATE-03 requirement - audit logs queryable by time range, status, service name. Supports filtering combinations for operational insights and debugging.

Output: AuditService with query methods, REST API endpoints, comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-and-audit/05-CONTEXT.md
@.planning/phases/05-state-and-audit/05-RESEARCH.md

@src/common/models.py
@src/orchestrator/api.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuditService with query methods</name>
  <files>src/orchestrator/audit.py</files>
  <action>
Create AuditService class with methods for querying execution history.

**Implementation:**

```python
"""Audit service for querying task execution history.

Provides methods for:
- Querying failures in time range (STATE-03: "all failures in last week")
- Querying by service name (STATE-03: "all changes to service X")
- Combined filtering (status + time + service)
- Intent inference from outcome JSON
"""

import logging
from datetime import datetime, timedelta
from typing import List, Optional

from sqlalchemy import desc
from sqlalchemy.orm import Session

from src.common.models import Task

logger = logging.getLogger(__name__)


class AuditService:
    """Service for querying task audit records.

    Uses GIN index on services_touched for efficient array containment queries.
    Uses composite index on (status, created_at) for time-range queries.
    """

    def __init__(self, db: Session):
        self.db = db
        self.logger = logging.getLogger("orchestrator.audit")

    def get_failures(
        self,
        days: int = 7,
        service: Optional[str] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[Task]:
        """Get failed tasks in the specified time range.

        Implements STATE-03: "all failures in last week"

        Args:
            days: Look back N days (default 7)
            service: Optional service name filter
            limit: Max results (default 100)
            offset: Pagination offset (default 0)

        Returns:
            List of failed Task records, newest first
        """
        cutoff = datetime.utcnow() - timedelta(days=days)
        query = self.db.query(Task).filter(
            Task.status == "failed",
            Task.created_at > cutoff,
        )

        if service:
            # Use GIN index with contains() operator
            query = query.filter(Task.services_touched.contains([service]))

        self.logger.info(
            f"Querying failures: days={days}, service={service}, limit={limit}"
        )

        return (
            query.order_by(desc(Task.created_at))
            .offset(offset)
            .limit(limit)
            .all()
        )

    def get_by_service(
        self,
        service_name: str,
        status: Optional[str] = None,
        days: Optional[int] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[Task]:
        """Get all tasks that touched a specific service.

        Implements STATE-03: "all changes to service X"

        Args:
            service_name: Service name to filter by
            status: Optional status filter
            days: Optional time range in days
            limit: Max results (default 100)
            offset: Pagination offset (default 0)

        Returns:
            List of Task records touching this service, newest first
        """
        # Use GIN index with contains() operator - NOT any()
        query = self.db.query(Task).filter(
            Task.services_touched.contains([service_name])
        )

        if status:
            query = query.filter(Task.status == status)

        if days:
            cutoff = datetime.utcnow() - timedelta(days=days)
            query = query.filter(Task.created_at > cutoff)

        self.logger.info(
            f"Querying by service: service={service_name}, status={status}, days={days}"
        )

        return (
            query.order_by(desc(Task.created_at))
            .offset(offset)
            .limit(limit)
            .all()
        )

    def audit_query(
        self,
        status: Optional[str] = None,
        service: Optional[str] = None,
        intent: Optional[str] = None,
        days: Optional[int] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[Task]:
        """Combined audit query with multiple optional filters.

        Supports combined filtering: status + time range + service + intent.
        Intent is inferred from outcome JSON field (action_type).

        Args:
            status: Filter by task status
            service: Filter by service in services_touched
            intent: Filter by action type in outcome JSON
            days: Filter by time range
            limit: Max results
            offset: Pagination offset

        Returns:
            List of matching Task records, newest first
        """
        query = self.db.query(Task)

        if status:
            query = query.filter(Task.status == status)

        if service:
            query = query.filter(Task.services_touched.contains([service]))

        if days:
            cutoff = datetime.utcnow() - timedelta(days=days)
            query = query.filter(Task.created_at > cutoff)

        if intent:
            # Infer intent from outcome JSON using JSONB path
            query = query.filter(
                Task.outcome["action_type"].astext == intent
            )

        self.logger.info(
            f"Audit query: status={status}, service={service}, intent={intent}, days={days}"
        )

        return (
            query.order_by(desc(Task.created_at))
            .offset(offset)
            .limit(limit)
            .all()
        )

    def get_task_count(
        self,
        status: Optional[str] = None,
        service: Optional[str] = None,
        days: Optional[int] = None,
    ) -> int:
        """Get count of matching tasks for pagination.

        Args:
            status: Optional status filter
            service: Optional service filter
            days: Optional time range

        Returns:
            Count of matching tasks
        """
        query = self.db.query(Task)

        if status:
            query = query.filter(Task.status == status)

        if service:
            query = query.filter(Task.services_touched.contains([service]))

        if days:
            cutoff = datetime.utcnow() - timedelta(days=days)
            query = query.filter(Task.created_at > cutoff)

        return query.count()
```

**Key design decisions:**
- Uses `.contains([service])` NOT `.any(service)` to leverage GIN index
- All queries use `order_by(desc(created_at))` for newest-first
- Intent filtering uses JSONB path query (`outcome['action_type'].astext`)
- Pagination with limit/offset for large result sets
- Separate count method for pagination headers
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && python -c "from src.orchestrator.audit import AuditService; print('AuditService imported successfully')"`
Expected: No import errors
  </verify>
  <done>
AuditService exists with get_failures(), get_by_service(), audit_query(), get_task_count() methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add REST API endpoints for audit queries</name>
  <files>src/orchestrator/api.py</files>
  <action>
Extend the existing api.py with audit endpoints.

**Add to api.py:**

1. Import AuditService:
```python
from src.orchestrator.audit import AuditService
```

2. Add Pydantic response models (after existing models):
```python
class TaskAuditResponse(BaseModel):
    """Response model for a single task in audit results."""
    task_id: str
    status: str
    request_text: str
    services_touched: Optional[List[str]] = None
    outcome: Optional[dict] = None
    created_at: str
    completed_at: Optional[str] = None
    error_message: Optional[str] = None


class AuditQueryResponse(BaseModel):
    """Response for audit queries with pagination."""
    tasks: List[TaskAuditResponse]
    total: int
    limit: int
    offset: int
```

3. Add helper function to convert Task to response:
```python
def task_to_audit_response(task: Task) -> TaskAuditResponse:
    """Convert Task ORM object to audit response."""
    return TaskAuditResponse(
        task_id=str(task.task_id),
        status=task.status,
        request_text=task.request_text,
        services_touched=task.services_touched,
        outcome=task.outcome,
        created_at=task.created_at.isoformat() if task.created_at else None,
        completed_at=task.completed_at.isoformat() if task.completed_at else None,
        error_message=task.error_message,
    )
```

4. Add audit endpoints:

```python
@router.get("/audit/failures", response_model=AuditQueryResponse)
async def get_failures(
    days: int = Query(7, ge=1, le=90, description="Look back N days"),
    service: Optional[str] = Query(None, description="Filter by service name"),
    limit: int = Query(100, ge=1, le=1000, description="Max results"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    db: Session = Depends(get_db),
):
    """Get all failed tasks in the specified time range.

    Implements STATE-03: "all failures in last week"
    """
    audit = AuditService(db)
    tasks = audit.get_failures(days=days, service=service, limit=limit, offset=offset)
    total = audit.get_task_count(status="failed", service=service, days=days)

    return AuditQueryResponse(
        tasks=[task_to_audit_response(t) for t in tasks],
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/audit/by-service/{service_name}", response_model=AuditQueryResponse)
async def get_by_service(
    service_name: str,
    status: Optional[str] = Query(None, description="Filter by status"),
    days: Optional[int] = Query(None, ge=1, le=365, description="Look back N days"),
    limit: int = Query(100, ge=1, le=1000, description="Max results"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    db: Session = Depends(get_db),
):
    """Get all tasks that touched a specific service.

    Implements STATE-03: "all changes to service X"
    """
    audit = AuditService(db)
    tasks = audit.get_by_service(
        service_name=service_name, status=status, days=days, limit=limit, offset=offset
    )
    total = audit.get_task_count(status=status, service=service_name, days=days)

    return AuditQueryResponse(
        tasks=[task_to_audit_response(t) for t in tasks],
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/audit/query", response_model=AuditQueryResponse)
async def audit_query(
    status: Optional[str] = Query(None, description="Filter by status"),
    service: Optional[str] = Query(None, description="Filter by service name"),
    intent: Optional[str] = Query(None, description="Filter by inferred intent"),
    days: Optional[int] = Query(None, ge=1, le=365, description="Look back N days"),
    limit: int = Query(100, ge=1, le=1000, description="Max results"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    db: Session = Depends(get_db),
):
    """Combined audit query with multiple optional filters.

    Supports combined filtering: status + time range + service + intent.
    """
    audit = AuditService(db)
    tasks = audit.audit_query(
        status=status, service=service, intent=intent, days=days, limit=limit, offset=offset
    )
    total = audit.get_task_count(status=status, service=service, days=days)

    return AuditQueryResponse(
        tasks=[task_to_audit_response(t) for t in tasks],
        total=total,
        limit=limit,
        offset=offset,
    )
```

**Note:** Ensure the get_db dependency is available (already exists in api.py).
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && python -c "from src.orchestrator.api import router; routes = [r.path for r in router.routes]; print('Audit routes:', [r for r in routes if 'audit' in r])"`
Expected: Shows /audit/failures, /audit/by-service/{service_name}, /audit/query
  </verify>
  <done>
REST API has /api/v1/audit/failures, /api/v1/audit/by-service/{service_name}, /api/v1/audit/query endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite for audit service</name>
  <files>tests/test_audit_service.py</files>
  <action>
Create test file with comprehensive coverage for AuditService and REST endpoints.

**Test cases:**

**AuditService unit tests:**

1. **test_get_failures_returns_failed_only**: Create tasks with mixed statuses, get_failures returns only failed ones

2. **test_get_failures_respects_time_range**: Create task 10 days ago, get_failures(days=7) excludes it

3. **test_get_failures_filters_by_service**: Create failed tasks for different services, filter by service works

4. **test_get_by_service_uses_gin_index**: Query by service returns matching tasks (integration test verifies index usage)

5. **test_get_by_service_with_status_filter**: Filter by service + status works together

6. **test_get_by_service_with_time_filter**: Filter by service + time range works together

7. **test_audit_query_combined_filters**: Test all filters together: status + service + days

8. **test_audit_query_intent_filter**: Create task with outcome JSON containing action_type, filter by intent works

9. **test_get_task_count_matches_results**: Count matches actual query results length

10. **test_pagination_limit_offset**: Limit and offset work correctly

**REST API integration tests:**

11. **test_api_failures_endpoint**: GET /api/v1/audit/failures returns correct format

12. **test_api_failures_query_params**: Query params (days, service, limit) work

13. **test_api_by_service_endpoint**: GET /api/v1/audit/by-service/{name} returns correct tasks

14. **test_api_query_endpoint_combined**: GET /api/v1/audit/query with multiple params

15. **test_api_response_format**: Response has tasks, total, limit, offset fields

16. **test_api_empty_results**: Empty query returns empty tasks array, total=0

**Use pytest-asyncio and TestClient from FastAPI. Create test fixtures for tasks with various statuses and services.**
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && pytest tests/test_audit_service.py -v`
Expected: All 16 tests pass
  </verify>
  <done>
All audit service tests pass. Query methods work correctly with GIN index, REST endpoints return proper JSON, pagination works.
  </done>
</task>

</tasks>

<verification>
1. Service imports: `from src.orchestrator.audit import AuditService` works
2. API routes exist: /audit/failures, /audit/by-service/{name}, /audit/query
3. Query works: `AuditService(db).get_failures()` returns Task list
4. API works: `curl localhost:8000/api/v1/audit/failures` returns JSON
5. Tests pass: `pytest tests/test_audit_service.py -v` all green
</verification>

<success_criteria>
- AuditService exists with get_failures(), get_by_service(), audit_query()
- REST endpoints /api/v1/audit/* return paginated JSON responses
- GIN index used for service containment queries (verify with EXPLAIN if needed)
- Combined filtering works (status + time + service + intent)
- All 16 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-and-audit/05-03-SUMMARY.md`
</output>
