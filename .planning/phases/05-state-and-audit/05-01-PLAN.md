---
phase: 05-state-and-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/versions/004_audit_columns.py
  - src/common/models.py
autonomous: true

must_haves:
  truths:
    - "Tasks table has services_touched ARRAY column with GIN index"
    - "Tasks table has outcome JSONB column for execution results"
    - "Tasks table has suggestions JSONB column for post-mortem scaffolding"
    - "UPDATE/DELETE on completed tasks raises PostgreSQL exception"
    - "pause_queue table exists for persisting paused work"
  artifacts:
    - path: "migrations/versions/004_audit_columns.py"
      provides: "Alembic migration for audit fields and immutability trigger"
      contains: "enforce_task_immutability"
    - path: "src/common/models.py"
      provides: "Extended Task ORM with audit fields"
      contains: "services_touched"
  key_links:
    - from: "migrations/versions/004_audit_columns.py"
      to: "src/common/models.py"
      via: "Column definitions must match"
      pattern: "services_touched.*ARRAY"
---

<objective>
Add audit columns to tasks table, create append-only trigger for immutability, and create pause_queue table for state persistence.

Purpose: Foundation for execution tracking, audit queries, and pause/resume mechanism. Tasks become immutable after completion (PostgreSQL-enforced), enabling reliable audit trails.

Output: Migration 004 with schema changes, Task model updated with audit fields, trigger tested.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-and-audit/05-CONTEXT.md
@.planning/phases/05-state-and-audit/05-RESEARCH.md

@src/common/models.py
@migrations/versions/003_desktop_agent_resources.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Alembic migration for audit columns and immutability trigger</name>
  <files>migrations/versions/004_audit_columns.py</files>
  <action>
Create Alembic migration with revision ID "004" and down_revision "003".

**Upgrade function must:**

1. Add columns to tasks table:
   - `services_touched`: ARRAY(TEXT), nullable=True
   - `outcome`: JSONB, nullable=True (execution result: success/error, output summary)
   - `suggestions`: JSONB, nullable=True (scaffolding for v2 post-mortem)

2. Create GIN index on services_touched:
   ```sql
   CREATE INDEX idx_tasks_services_touched ON tasks USING GIN (services_touched);
   ```

3. Create composite index for status + time queries:
   ```sql
   CREATE INDEX idx_tasks_status_created_at ON tasks (status, created_at DESC);
   ```

4. Create append-only trigger function:
   ```sql
   CREATE OR REPLACE FUNCTION prevent_task_modification()
   RETURNS trigger AS $$
   BEGIN
       IF TG_OP = 'UPDATE' THEN
           -- Allow status transitions for non-completed tasks
           IF OLD.status IN ('pending', 'approved', 'executing') THEN
               RETURN NEW;
           END IF;
           RAISE EXCEPTION 'UPDATE not allowed on completed task (task_id=%)', OLD.task_id;
       ELSIF TG_OP = 'DELETE' THEN
           RAISE EXCEPTION 'DELETE not allowed on tasks table (task_id=%)', OLD.task_id;
       END IF;
       RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;
   ```

5. Attach trigger to tasks table:
   ```sql
   CREATE TRIGGER enforce_task_immutability
   BEFORE UPDATE OR DELETE ON tasks
   FOR EACH ROW
   EXECUTE FUNCTION prevent_task_modification();
   ```

6. Create pause_queue table:
   - `id`: Integer, primary_key, autoincrement
   - `task_id`: UUID, FK to tasks.task_id, NOT NULL
   - `work_plan_json`: JSONB, NOT NULL (serialized WorkPlan)
   - `reason`: String(100), NOT NULL ('insufficient_capacity', 'manual_pause')
   - `paused_at`: DateTime, server_default=now()
   - `resume_after`: DateTime, nullable (for timed auto-resume)
   - `priority`: Integer, server_default=3

7. Create index on pause_queue for resume queries:
   ```sql
   CREATE INDEX idx_pause_queue_resume ON pause_queue (resume_after, priority);
   ```

**Downgrade function must:**
- Drop pause_queue table
- Drop trigger enforce_task_immutability
- Drop function prevent_task_modification
- Drop both indexes
- Drop suggestions, outcome, services_touched columns
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && alembic upgrade head`
Verify: No errors, migration applies cleanly
Check with psql: `\d tasks` shows new columns; `\df prevent_task_modification` shows trigger function exists
  </verify>
  <done>
Migration 004 applies without errors. tasks table has services_touched (array), outcome (jsonb), suggestions (jsonb). Trigger function and pause_queue table created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Task ORM model with audit fields</name>
  <files>src/common/models.py</files>
  <action>
Update the Task class in models.py to include the new audit columns.

**Add imports:**
```python
from sqlalchemy.dialects.postgresql import ARRAY, JSONB
```

**Add columns to Task class (after error_message field):**

```python
# Audit columns (Phase 5)
services_touched = Column(ARRAY(String), nullable=True)
# Array of service names touched by this task (e.g., ["kuma", "portainer"])

outcome = Column(JSONB, nullable=True)
# Execution outcome: {"success": bool, "output_summary": str, "error_type": str|null}

suggestions = Column(JSONB, nullable=True)
# Post-mortem scaffolding: [{"suggestion": str, "reason": str, "created_at": str}]
# Unpopulated in v1; v2 post-mortem agent will populate
```

**Create new PauseQueueEntry ORM model:**

```python
class PauseQueueEntry(Base):
    """Persisted pause queue entry for work awaiting resources.

    Used by PauseManager to persist paused work that survives orchestrator restart.
    Entries removed when work resumes or is cancelled.
    """
    __tablename__ = "pause_queue"

    id = Column(Integer, primary_key=True, autoincrement=True)
    task_id = Column(UUID(as_uuid=True), ForeignKey("tasks.task_id"), nullable=False)
    work_plan_json = Column(JSONB, nullable=False)
    reason = Column(String(100), nullable=False)
    paused_at = Column(DateTime, nullable=False, default=func.now())
    resume_after = Column(DateTime, nullable=True)
    priority = Column(Integer, nullable=False, default=3)

    # Relationship
    task = relationship("Task")

    def __repr__(self):
        return f"<PauseQueueEntry(id={self.id}, task_id={self.task_id}, reason={self.reason})>"
```

**Also add Pydantic model for pause entry serialization:**

```python
class PauseQueueEntryModel(BaseModel):
    """Pydantic model for pause queue entry serialization."""
    id: Optional[int] = None
    task_id: str
    work_plan: WorkPlan
    reason: str
    paused_at: datetime
    resume_after: Optional[datetime] = None
    priority: int = 3
```
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && python -c "from src.common.models import Task, PauseQueueEntry; print('Task.services_touched:', Task.services_touched); print('PauseQueueEntry:', PauseQueueEntry.__tablename__)"`
Expected: No import errors, column and table names printed
  </verify>
  <done>
Task model has services_touched, outcome, suggestions columns. PauseQueueEntry ORM model exists. Both can be imported without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test immutability trigger and indexes</name>
  <files>tests/test_audit_schema.py</files>
  <action>
Create test file to verify the migration works correctly.

**Test cases:**

1. **test_services_touched_gin_index**: Create task with services_touched, query with `.contains()`, verify GIN index is used (EXPLAIN shows Index Scan)

2. **test_status_created_at_index**: Query tasks by status + created_at, verify composite index used

3. **test_trigger_allows_status_transitions**: Create pending task, update to executing, then to completed. All should succeed.

4. **test_trigger_blocks_completed_update**: Create completed task, try to UPDATE outcome field. Should raise IntegrityError with message containing "UPDATE not allowed".

5. **test_trigger_blocks_delete**: Create any task, try to DELETE. Should raise IntegrityError with message containing "DELETE not allowed".

6. **test_pause_queue_creation**: Create PauseQueueEntry, verify it persists and can be queried.

7. **test_pause_queue_skip_locked**: Insert multiple entries, use FOR UPDATE SKIP LOCKED query pattern, verify only one returned per transaction.

**Use pytest-asyncio with the test database fixture pattern from existing tests.**
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && pytest tests/test_audit_schema.py -v`
Expected: All 7 tests pass
  </verify>
  <done>
All schema tests pass. Trigger correctly allows status transitions, blocks modifications on completed tasks, blocks all deletes. GIN index works for array containment queries.
  </done>
</task>

</tasks>

<verification>
1. Migration applies: `alembic upgrade head` succeeds
2. Migration reverts: `alembic downgrade -1` then `alembic upgrade head` succeeds
3. Schema correct: `\d tasks` shows new columns
4. Trigger exists: `\df prevent_task_modification` shows function
5. Tests pass: `pytest tests/test_audit_schema.py -v` all green
</verification>

<success_criteria>
- Migration 004 exists and applies cleanly
- tasks table has services_touched (ARRAY), outcome (JSONB), suggestions (JSONB)
- GIN index on services_touched enables fast containment queries
- Composite index on (status, created_at) enables fast audit queries
- Trigger prevents UPDATE on completed tasks, prevents all DELETE
- pause_queue table exists with correct schema
- All 7 schema tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-and-audit/05-01-SUMMARY.md`
</output>
