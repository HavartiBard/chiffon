---
phase: 05-state-and-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/common/resource_tracker.py
  - tests/test_resource_tracker.py
autonomous: true

must_haves:
  truths:
    - "Resource tracker captures CPU time (user + system)"
    - "Resource tracker captures wall clock duration"
    - "Resource tracker captures peak memory usage"
    - "Resource tracker captures GPU VRAM if available"
    - "GPU unavailability handled gracefully (zeros returned)"
  artifacts:
    - path: "src/common/resource_tracker.py"
      provides: "psutil/pynvml wrapper for resource metrics capture"
      exports: ["capture_resource_snapshot", "calculate_resource_usage"]
    - path: "tests/test_resource_tracker.py"
      provides: "Test suite for resource tracker"
      min_lines: 100
  key_links:
    - from: "src/common/resource_tracker.py"
      to: "psutil"
      via: "import psutil"
      pattern: "psutil\\.Process"
---

<objective>
Create resource tracking module using psutil and pynvml to capture CPU time, memory, GPU VRAM during task execution.

Purpose: Provides accurate resource_used data for audit records. Captures metrics before and after work execution, calculates delta for storage in Task.actual_resources.

Output: ResourceTracker class with snapshot/delta methods, graceful GPU fallback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-and-audit/05-CONTEXT.md
@.planning/phases/05-state-and-audit/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resource tracker module</name>
  <files>src/common/resource_tracker.py</files>
  <action>
Create resource tracking module for capturing execution metrics.

**Implementation:**

```python
"""Resource tracking for task execution metrics.

Captures CPU time, memory, GPU VRAM before/after task execution.
Used by orchestrator to populate Task.actual_resources for audit trail.

Uses:
- psutil: CPU time (user + system), memory (RSS, VMS)
- pynvml: NVIDIA GPU VRAM (optional, graceful fallback)
"""

import logging
import time
from dataclasses import dataclass
from typing import Optional

import psutil

logger = logging.getLogger(__name__)

# Try importing pynvml for GPU tracking
try:
    import pynvml
    pynvml.nvmlInit()
    HAS_GPU = True
    logger.info("pynvml initialized successfully - GPU tracking enabled")
except Exception as e:
    HAS_GPU = False
    logger.info(f"pynvml not available ({e}) - GPU tracking disabled")


@dataclass
class ResourceSnapshot:
    """Snapshot of resource state at a point in time."""
    cpu_user_seconds: float
    cpu_system_seconds: float
    memory_rss_bytes: int
    memory_vms_bytes: int
    wall_clock_time: float
    gpu_vram_used_bytes: Optional[int] = None
    gpu_vram_total_bytes: Optional[int] = None


def capture_resource_snapshot(
    process: Optional[psutil.Process] = None,
    gpu_index: int = 0
) -> ResourceSnapshot:
    """Capture current resource metrics for a process.

    Args:
        process: psutil.Process to measure. Defaults to current process.
        gpu_index: NVIDIA GPU index to query (default 0).

    Returns:
        ResourceSnapshot with current metrics.
    """
    if process is None:
        process = psutil.Process()

    cpu_times = process.cpu_times()
    memory_info = process.memory_info()

    snapshot = ResourceSnapshot(
        cpu_user_seconds=cpu_times.user,
        cpu_system_seconds=cpu_times.system,
        memory_rss_bytes=memory_info.rss,
        memory_vms_bytes=memory_info.vms,
        wall_clock_time=time.time(),
    )

    # Try GPU metrics if available
    if HAS_GPU:
        try:
            handle = pynvml.nvmlDeviceGetHandleByIndex(gpu_index)
            mem_info = pynvml.nvmlDeviceGetMemoryInfo(handle)
            snapshot.gpu_vram_used_bytes = mem_info.used
            snapshot.gpu_vram_total_bytes = mem_info.total
        except Exception as e:
            logger.debug(f"GPU metrics unavailable: {e}")

    return snapshot


@dataclass
class ResourceUsage:
    """Calculated resource usage between two snapshots."""
    cpu_time_seconds: float
    wall_clock_seconds: float
    peak_memory_bytes: int
    gpu_vram_used_bytes: int


def calculate_resource_usage(
    start: ResourceSnapshot,
    end: ResourceSnapshot
) -> ResourceUsage:
    """Calculate resource delta between start and end snapshots.

    Args:
        start: Snapshot taken before work.
        end: Snapshot taken after work.

    Returns:
        ResourceUsage with calculated deltas.
    """
    cpu_time = (
        (end.cpu_user_seconds - start.cpu_user_seconds) +
        (end.cpu_system_seconds - start.cpu_system_seconds)
    )

    wall_clock = end.wall_clock_time - start.wall_clock_time

    # Peak memory is max of start/end RSS
    peak_memory = max(start.memory_rss_bytes, end.memory_rss_bytes)

    # GPU VRAM: use end snapshot if available, else 0
    gpu_vram = end.gpu_vram_used_bytes if end.gpu_vram_used_bytes else 0

    return ResourceUsage(
        cpu_time_seconds=cpu_time,
        wall_clock_seconds=wall_clock,
        peak_memory_bytes=peak_memory,
        gpu_vram_used_bytes=gpu_vram,
    )


def resource_usage_to_dict(usage: ResourceUsage) -> dict:
    """Convert ResourceUsage to dict for JSON serialization.

    Format matches Task.actual_resources expected structure.
    """
    return {
        "cpu_time_seconds": round(usage.cpu_time_seconds, 3),
        "wall_clock_seconds": round(usage.wall_clock_seconds, 3),
        "peak_memory_mb": round(usage.peak_memory_bytes / (1024 * 1024), 2),
        "gpu_vram_used_mb": round(usage.gpu_vram_used_bytes / (1024 * 1024), 2),
    }


class ResourceTracker:
    """Context manager for tracking resource usage during task execution.

    Usage:
        async with ResourceTracker() as tracker:
            # Do work...

        usage_dict = tracker.get_usage_dict()
        task.actual_resources = usage_dict
    """

    def __init__(self, gpu_index: int = 0):
        self.gpu_index = gpu_index
        self.start_snapshot: Optional[ResourceSnapshot] = None
        self.end_snapshot: Optional[ResourceSnapshot] = None

    async def __aenter__(self):
        self.start_snapshot = capture_resource_snapshot(gpu_index=self.gpu_index)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self.end_snapshot = capture_resource_snapshot(gpu_index=self.gpu_index)
        return False

    def __enter__(self):
        self.start_snapshot = capture_resource_snapshot(gpu_index=self.gpu_index)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_snapshot = capture_resource_snapshot(gpu_index=self.gpu_index)
        return False

    def get_usage(self) -> ResourceUsage:
        """Get calculated resource usage after context exits."""
        if not self.start_snapshot or not self.end_snapshot:
            raise RuntimeError("ResourceTracker must be used as context manager")
        return calculate_resource_usage(self.start_snapshot, self.end_snapshot)

    def get_usage_dict(self) -> dict:
        """Get resource usage as dict for JSON storage."""
        return resource_usage_to_dict(self.get_usage())
```

**Key design decisions:**
- Uses psutil.Process() for accurate per-process metrics
- pynvml initialization at module load (once)
- Graceful fallback: HAS_GPU=False if pynvml unavailable
- Both sync and async context manager support
- Dict output matches Task.actual_resources expected format
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && python -c "from src.common.resource_tracker import ResourceTracker, capture_resource_snapshot; print(capture_resource_snapshot())"`
Expected: ResourceSnapshot printed with CPU/memory values (GPU may be 0)
  </verify>
  <done>
ResourceTracker module exists, can capture snapshots, returns valid metrics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive test suite for resource tracker</name>
  <files>tests/test_resource_tracker.py</files>
  <action>
Create test file with comprehensive coverage.

**Test cases:**

1. **test_capture_snapshot_has_cpu_metrics**: Snapshot has cpu_user_seconds >= 0 and cpu_system_seconds >= 0

2. **test_capture_snapshot_has_memory_metrics**: Snapshot has memory_rss_bytes > 0 and memory_vms_bytes > 0

3. **test_capture_snapshot_has_wall_clock**: Snapshot has wall_clock_time close to time.time()

4. **test_calculate_usage_cpu_time**: Two snapshots with time.sleep(0.1) between, cpu_time_seconds > 0

5. **test_calculate_usage_wall_clock**: Two snapshots with time.sleep(0.1) between, wall_clock_seconds >= 0.1

6. **test_calculate_usage_peak_memory**: Peak memory >= start memory

7. **test_resource_usage_to_dict_format**: Dict has expected keys: cpu_time_seconds, wall_clock_seconds, peak_memory_mb, gpu_vram_used_mb

8. **test_resource_tracker_context_manager**: Use `with ResourceTracker() as tracker`, verify get_usage_dict() returns valid dict

9. **test_resource_tracker_async_context_manager**: Use `async with ResourceTracker() as tracker`, verify works in async context

10. **test_gpu_unavailable_graceful_fallback**: Even without GPU, snapshot/usage work and return 0 for GPU fields

11. **test_resource_tracker_error_before_exit**: Calling get_usage() before __exit__ raises RuntimeError

**Use pytest with standard fixtures. No external services required.**
  </action>
  <verify>
Run: `cd /home/james/Projects/chiffon && pytest tests/test_resource_tracker.py -v`
Expected: All 11 tests pass
  </verify>
  <done>
All resource tracker tests pass. CPU/memory metrics accurate, wall clock timing works, GPU fallback graceful, context manager pattern validated.
  </done>
</task>

</tasks>

<verification>
1. Module imports: `from src.common.resource_tracker import ResourceTracker` works
2. Snapshot captures: `capture_resource_snapshot()` returns valid metrics
3. Usage calculation: `calculate_resource_usage(start, end)` returns deltas
4. Context manager: `with ResourceTracker() as t: ...` captures metrics
5. Tests pass: `pytest tests/test_resource_tracker.py -v` all green
</verification>

<success_criteria>
- ResourceTracker module exists at src/common/resource_tracker.py
- capture_resource_snapshot() returns CPU time, memory, wall clock, optional GPU
- calculate_resource_usage() computes deltas correctly
- ResourceTracker context manager captures start/end and provides usage dict
- GPU unavailability handled gracefully (returns 0, no exceptions)
- All 11 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-and-audit/05-02-SUMMARY.md`
</output>
